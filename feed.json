{
    "providerName":"media.ccc.de",
    "lastUpdated":"2019-10-30T00:00:00+00:00",
    "language":"en",
    "categories":[
        {
            "name":"Chaos Computer Congresses",
            "query":"congress",
            "order":"most_recent"
        }
    ],
    "series":[
        {
            "id":"congress/2018",
            "title":"35C3 Refreshing Memories",
            "genres":[
                "educational"
            ],
            "tags":[
                "congress",
                "2018",
                "35C3"
            ],
            "thumbnail":"https://www.combee.net/roku-ccc/35c3_1920x1080_logo.jpg",
            "releaseDate":"2018-12-28",
            "shortDescription":"The 35th Chaos Communication Congress (35C3) was the 2018 edition of the annual four-day conference on technology, society and utopia organised by the Chaos Computer Club (CCC) and volunteers.",
            "episodes":[
                {
                    "id":"7ee42591-4f4d-481d-884b-44f5e18e1803",
                    "title":"In Soviet Russia Smart Card Hacks You",
                    "episodeNumber": 9346,
                    "releaseDate":"2018-12-30T00:00:00+00:00",
                    "credits":[
                        {
                            "name":"Eric Sesterhenn",
                            "role":"actor"
                        }
                    ],
                    "content":{
                        "dateAdded":"2018-12-30T00:00:00+00:00",
                        "videos":[
                            {
                                "url":"https://cdn.media.ccc.de/congress/2018/h264-hd/35c3-9346-eng-In_Soviet_Russia_Smart_Card_Hacks_You.mp4",
                                "quality":"HD",
                                "videoType":"MP4"
                            }
                        ],
                        "duration":2295,
                        "language":"en"
                    },
                    "thumbnail":"https://static.media.ccc.de/media/congress/2018/9346-hd_preview.jpg",
                    "shortDescription":"The classic spy movie hacking sequence: The spy inserts a magic smart card provided by the agency technicians into the enemy's computer, … the screen unlocks … What we all laughed about is possible!",
                    "longDescription":"The classic spy movie hacking sequence: The spy inserts a magic smart card provided by the agency technicians into the enemy's computer, … the screen unlocks … What we all laughed about is possible!\n\nSmartcards are secure and trustworthy. This is the idea smart card driver developers have in mind when developing drivers and smart card software. The work presented in this talk not only challenges, but crushes this assumption by attacking drivers using malicious smart cards.\n\nWe will present a fuzzing framework for *nix and Windows along with some interesting bugs found by auditing and fuzzing smart card drivers and middleware. Among them classic stack and heap buffer overflows, double frees, but also a replay attack against smart card authentication.\n\nSince smart cards are used in the authentication process, a lot of vulnerabilities can be triggered by an unauthenticated user, in code running with high privileges. During the author's research, bugs were discovered in OpenSC (EPass, PIV, OpenPGP, CAC, Cryptoflex …), YubiKey drivers, pam_p11, pam_pkc11, Apple's smartcard-services and others."
                },
                {
                    "id":"5a8097ad-15c2-492e-8bc4-6b634fd8e963",
                    "title":"Russia vs. Telegram: technical notes on the battle",
                    "episodeNumber": 9653,
                    "releaseDate":"2018-12-29T00:00:00+00:00",
                    "credits":[
                        {
                            "name":"Leonid Evdokimov (darkk)",
                            "role":"actor"
                        }
                    ],
                    "content":{
                        "dateAdded":"2018-12-29T00:00:00+00:00",
                        "videos":[
                            {
                                "url":"https://cdn.media.ccc.de/congress/2018/h264-hd/35c3-9653-eng-deu-fra-Russia_vs_Telegram_technical_notes_on_the_battle_hd.mp4",
                                "quality":"HD",
                                "videoType":"MP4"
                            }
                        ],
                        "duration":2452,
                        "language":"en"
                    },
                    "thumbnail":"https://static.media.ccc.de/media/congress/2018/9653-hd_preview.jpg",
                    "shortDescription":"It's time to highlight facts and epic fails that were observed on the wire during attempts to block Telegram in Russia.",
                    "longDescription":"It's time to highlight facts and epic fails that were observed on the wire during attempts to block Telegram in Russia.\n\n\nRussian Federal Service for Supervision of Communications, IT and Mass Media started the process to ban Telegram on April the 16th. Roskomnadzor press-office claimed that the process will take a few hours. Telegram mostly worked in Russia during the incident beginning and still works half a year later.\n\nRussia banned Amazon, Google, Microsoft, DigitalOcean, Hetzner and other networks covering almost 0.5% of Internet Protocol address space, presumably, to put pressure on international businesses to make Telegram persona non-grata on those networks.\n\nRussia also banned IP addresses of major local businesses (VKontakte, Yandex and others), presumably, by mistake. A flaw in the filter was exploited to bring one of the major ISPs down for a while. Moscow Internet exchange point announced that alike flaw of the filter could be used to disrupt peering. Proxy-hunting experiments were observed sniffing live network traffic, both for obfuscated MTProto proxy and good old Socks5.\n\nThis talk will <em>not</em> cover legal aspects of the lawyers fighting for Telegram in court. Also, it will <em>not</em> show any \"insider\" information from Telegram team."
                },
                {
                    "id":"2375222b-7dae-4bca-a5b0-aea227ab0d76",
                    "title":"A deep dive into the world of DOS viruses",
                    "episodeNumber": 9617,
                    "releaseDate":"2018-12-28T00:00:00.000+01:00",
                    "credits":[
                        {
                            "name":"Ben Cartwright-Cox",
                            "role":"actor"
                        }
                    ],
                    "content":{
                        "dateAdded":"2018-12-28T00:00:00.000+01:00",
                        "videos":[
                            {
                                "url":"https://cdn.media.ccc.de/congress/2018/h264-hd/35c3-9617-eng-A_deep_dive_into_the_world_of_DOS_viruses.mp4",
                                "quality":"HD",
                                "videoType":"MP4"
                            }
                        ],
                        "duration":2292,
                        "language":"en"
                    },
                    "thumbnail":"https://static.media.ccc.de/media/congress/2018/9617-hd_preview.jpg",
                    "shortDescription":"Explaining in detail just how those little COM files infected and played with us back in the day",
                    "longDescription":"It is now 27 years since MS-DOS 5.0 was released. During its day there was the threat of viruses breaking your system or making it act in unpredictable ways. Due to its age and near total lack of consumer use it is safe to assume that all of the viruses for MS-DOS have been written. Using community archives and modern analysis methods we can uncover how they worked and reflect on how things have changed.\n\nComputers have come a long way in the last 27 years, and so has malware too. This talk will start off with some of the most famous and widely known payloads. A basic guide on how MS-DOS runs applications, and we will work up from there to analysing all 17k+ samples with that are in the archives using automatic tooling to pick out some of the most interesting ones.\n\nIf you don’t have reverse engineering skills, don’t be afraid! We will start off with the basics of how the IBM PC works, MS DOS execution, binary runtime, and how we automatically run/disassemble/trace/fuzz malware on mass."
                },
                {
                    "id":"64d3f3f5-5665-4050-ba15-0db530ecc262",
                    "title":"Safe and Secure Drivers in High-Level Languages",
                    "episodeNumber": 9670,
                    "releaseDate": "2018-12-29T00:00:00.000+01:00",
                    "credits":[
                        {
                            "role":"actor",
                            "name":"Paul Emmerich"
                        },
                        {
                            "role":"actor",
                            "name":"Simon Ellmann"
                        },
                        {
                            "role":"actor",
                            "name":"Sebastian Voit"
                        }
                    ],
                    "content":{
                        "dateAdded":"2018-12-29T00:00:00.000+01:00",
                        "videos":[
                            {
                                "url":"https://cdn.media.ccc.de/congress/2018/h264-hd/35c3-9670-eng-Safe_and_Secure_Drivers_in_High-Level_Languages.mp4",
                                "quality":"HD",
                                "videoType":"MP4"
                            }
                        ],
                        "duration":3716,
                        "language":"en"
                    },
                    "thumbnail":"https://static.media.ccc.de/media/congress/2018/9617-hd_preview.jpg",
                    "shortDescription":"How to write PCIe drivers in Rust, go, C#, Swift, Haskell, and OCaml",
                    "longDescription":"Drivers are usually written in C for historical reasons, this can be bad if you want your driver to be safe and secure. We show that it is possible to write low-level drivers for PCIe devices in modern high-level languages.\nWe are working on super-fast user space network drivers for the Intel 82599ES (ixgbe) 10 Gbit/s NICs in different high-level languages. We've got fully working implementations in Rust, C#, go, OCaml, Haskell, and Swift. All of them are written from scratch and require no kernel code.\n\nCheck out <a href=\"https://github.com/ixy-languages/ixy-languages\">our GitHub page</a> with links to all implementations, performance measurements, and publications for further reading.\n\nSupposedly modern user space drivers (e.g., DPDK or SPDK) are still being written in C in 2018 :(\n\nThis comes with all the well-known drawbacks of writing things in C that might be prevented by using safer programming languages.\nAlso, did you ever see a kernel panic because a driver did something stupid? It doesn't have to be that way, drivers should not be able to take down the whole system.\n\nThere are three steps to building better drivers:\n\n1. Write them in a safer programming language eliminating whole classes of bugs and security problems like bad memory accesses\n\n2. Isolating them from the rest of the operating system: user space drivers that drop privileges\n\n3. Isolating the hardware using the IOMMU\n\n\nWe show that it is possible to achieve all of these goals for PCIe drivers on Linux by implementing user space network drivers in all of the aforementioned programming languages. Our techniques are transferable to other drivers that would benefit from more modern implementations. \n\nOur drivers in <a href=\"https://github.com/ixy-languages/ixy.rs\">Rust</a>, <a href=\"https://github.com/ixy-languages/ixy.cs\">C#</a>, <a href=\"https://github.com/ixy-languages/ixy.go\">go</a>, and <a href=\"https://github.com/ixy-languages/ixy.swift\">Swift</a> are completely finished, tuned for performance, evaluated, and benchmarked. And all of them except for Swift are about 80-90% as fast as <a href=\"https://github.com/emmericp/ixy\">our user space C driver</a> and 6-10 times faster than the kernel C driver. We also investigate how garbage collectod languages affects the latency of a packet forwarder built on top of our drivers.\n\nWe also got something for fans of functional languages: our implementations in <a href=\"https://github.com/ixy-languages/ixy.ml\">OCaml</a> and <a href=\"https://github.com/ixy-languages/ixy.hs\">Haskell</a> are working but not yet tuned for performance. We are also working on Python, Java, and Javascript.\nWe take a brief look at Haskell, Swift, OCaml, and C# in the talk and a deeper dive into Rust and Go.\n\nThe talk also features a quick summary from <a href=\"https://media.ccc.de/v/34c3-9159-demystifying_network_cards\">last year's talk about user space driver basics</a>, so no previous knowledge is required.\n\n\nAnother thing to take away from this talk is: writing drivers is neither scary nor hard. You can write one in your favorite programming language, so go ahead and try that :)\n\n\n<a href=\"https://media.ccc.de/v/34c3-9159-demystifying_network_cards\">https://media.ccc.de/v/34c3-9159-demystifying_network_cards</a>\n\n<a href=\"https://github.com/ixy-languages/ixy-languages\">https://github.com/ixy-languages/ixy-languages</a>"
                }
            ]
        }
    ]
}